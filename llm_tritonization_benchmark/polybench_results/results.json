{
  "2mm": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "3mm": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 2,
    "final_error": {
      "type": "unknown",
      "message": "  Test 1: ERROR - at 11:24:\ndef k3mm_kernel(\n    A_ptr, B_ptr, C_ptr, D_ptr, E_ptr, F_ptr, G_ptr,\n    NI, NJ, NK, NL, NM,\n    BLOCK_SIZE: tl.constexpr\n):\n    # E := A*B\n    for i in range(NI):\n        for j in range(NJ):\n            accumulator = 0.0\n            for k in range(NK):\n                a_val = tl.load(A_ptr + i * NK + k)\n                        ^\n  Test 2: ERROR - at 11:24:\ndef k3mm_kernel(\n    A_ptr, B_ptr, C_ptr, D_ptr, E_ptr, F_ptr, G_ptr,\n    NI, NJ, NK, NL, NM,\n    BLOCK_SIZE: tl.constexpr\n):\n    # E := A*B\n    for i in range(NI):\n        for j in range(NJ):\n            accumulator = 0.0\n            for k in range(NK):\n                a_val = tl.load(A_ptr + i * NK + k)\n                        ^\n  Test 3: ERROR - at 11:24:\ndef k3mm_kernel(\n    A_ptr, B_ptr, C_ptr, D_ptr, E_ptr, F_ptr, G_ptr,\n    NI, NJ, NK, NL, NM,\n    BLOCK_SIZE: tl.constexpr\n):\n    # E := A*B\n    for i in range(NI):\n        for j in range(NJ):\n            accumulator = 0.0\n            for k in range(NK):\n                a_val = tl.load(A_ptr + i * NK + k)\n                        ^\nSome tests FAILED!\n"
    }
  },
  "adi": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 2,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 1.494688e-02",
      "max_error": "1.494688e-02"
    }
  },
  "atax": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "unknown",
      "message": "  Test 1: ERROR - at 6:24:\ndef init_y_kernel(y_ptr, N):\n    pid = tl.program_id(0)\n    BLOCK_SIZE = 64\n\n    y_start = pid * BLOCK_SIZE\n    offsets = y_start + tl.arange(0, BLOCK_SIZE)\n                        ^\n  Test 2: ERROR - at 6:24:\ndef init_y_kernel(y_ptr, N):\n    pid = tl.program_id(0)\n    BLOCK_SIZE = 64\n\n    y_start = pid * BLOCK_SIZE\n    offsets = y_start + tl.arange(0, BLOCK_SIZE)\n                        ^\n  Test 3: ERROR - at 6:24:\ndef init_y_kernel(y_ptr, N):\n    pid = tl.program_id(0)\n    BLOCK_SIZE = 64\n\n    y_start = pid * BLOCK_SIZE\n    offsets = y_start + tl.arange(0, BLOCK_SIZE)\n                        ^\nSome tests FAILED!\n"
    }
  },
  "bicg": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "cholesky": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "correlation": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 4,
    "final_error": {
      "type": "unknown",
      "message": "  Test 1: ERROR - at 18:12:\n    pid_j = tl.program_id(axis=1)\n\n    i_start = pid_i * BLOCK_SIZE\n    j_start = pid_j * BLOCK_SIZE\n\n    i_offsets = tl.arange(0, BLOCK_SIZE)\n    j_offsets = tl.arange(0, BLOCK_SIZE)\n\n    for ii in range(BLOCK_SIZE):\n        i_idx = i_start + ii\n        if i_idx >= M:\n            break\n            ^\nunsupported AST node type: Break\n  Test 2: ERROR - at 18:12:\n    pid_j = tl.program_id(axis=1)\n\n    i_start = pid_i * BLOCK_SIZE\n    j_start = pid_j * BLOCK_SIZE\n\n    i_offsets = tl.arange(0, BLOCK_SIZE)\n    j_offsets = tl.arange(0, BLOCK_SIZE)\n\n    for ii in range(BLOCK_SIZE):\n        i_idx = i_start + ii\n        if i_idx >= M:\n            break\n            ^\nunsupported AST node type: Break\n  Test 3: ERROR - at 18:12:\n    pid_j = tl.program_id(axis=1)\n\n    i_start = pid_i * BLOCK_SIZE\n    j_start = pid_j * BLOCK_SIZE\n\n    i_offsets = tl.arange(0, BLOCK_SIZE)\n    j_offsets = tl.arange(0, BLOCK_SIZE)\n\n    for ii in range(BLOCK_SIZE):\n        i_idx = i_start + ii\n        if i_idx >= M:\n            break\n            ^\nunsupported AST node type: Break\nSome tests FAILED!\n"
    }
  },
  "covariance": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 3.340769e+00",
      "max_error": "3.340769e+00"
    }
  },
  "deriche": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 3,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 1.615190e-01",
      "max_error": "1.615190e-01"
    }
  },
  "doitgen": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 1.512557e+05",
      "max_error": "1.512557e+05"
    }
  },
  "durbin": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 4.462755e-01",
      "max_error": "4.462755e-01"
    }
  },
  "fdtd_2d": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 2,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 2.766777e+02",
      "max_error": "2.766777e+02"
    }
  },
  "floyd_warshall": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = unknown",
      "max_error": "unknown"
    }
  },
  "gemm": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "gemver": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 4.882812e-04",
      "max_error": "4.882812e-04"
    }
  },
  "gesummv": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "gramschmidt": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 6.293507e-01",
      "max_error": "6.293507e-01"
    }
  },
  "heat_3d": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "jacobi_1d": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 2.750456e-04",
      "max_error": "2.750456e-04"
    }
  },
  "jacobi_2d": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 1.611739e+00",
      "max_error": "1.611739e+00"
    }
  },
  "lu": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "ludcmp": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 6.859375e+02",
      "max_error": "6.859375e+02"
    }
  },
  "mvt": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 3,
    "final_error": {
      "type": "unknown",
      "message": " # Compute dot product contribution\n                contribution = tl.sum(A_vals * y_1_vals)\n                x1_acc = tl.where(offsets == i_idx, contribution, 0.0) + tl.where(offsets == i_idx, 0.0, x1_acc)\n                x1_acc = tl.where(offsets == i_idx, x1_acc[0] + contribution, x1_acc)\n                                                    ^\nValueError('unsupported tensor index: constexpr[0]')\n  Test 2: ERROR - at 38:52:\n        # For each i in this block, process all j values\n        for i_idx in range(BLOCK_SIZE):\n            i_val = block_start + i_idx\n            if i_val < N:\n                # Load A[i][j] values for this row\n                A_row_offsets = i_val * N + j_current\n                A_vals = tl.load(A_ptr + A_row_offsets, mask=j_mask, other=0.0)\n\n                # Compute dot product contribution\n                contribution = tl.sum(A_vals * y_1_vals)\n                x1_acc = tl.where(offsets == i_idx, contribution, 0.0) + tl.where(offsets == i_idx, 0.0, x1_acc)\n                x1_acc = tl.where(offsets == i_idx, x1_acc[0] + contribution, x1_acc)\n                                                    ^\nValueError('unsupported tensor index: constexpr[0]')\n  Test 3: ERROR - at 38:52:\n        # For each i in this block, process all j values\n        for i_idx in range(BLOCK_SIZE):\n            i_val = block_start + i_idx\n            if i_val < N:\n                # Load A[i][j] values for this row\n                A_row_offsets = i_val * N + j_current\n                A_vals = tl.load(A_ptr + A_row_offsets, mask=j_mask, other=0.0)\n\n                # Compute dot product contribution\n                contribution = tl.sum(A_vals * y_1_vals)\n                x1_acc = tl.where(offsets == i_idx, contribution, 0.0) + tl.where(offsets == i_idx, 0.0, x1_acc)\n                x1_acc = tl.where(offsets == i_idx, x1_acc[0] + contribution, x1_acc)\n                                                    ^\nValueError('unsupported tensor index: constexpr[0]')\nSome tests FAILED!\n"
    }
  },
  "nussinov": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 4,
    "final_error": {
      "type": "unknown",
      "message": "  Test 1: ERROR - at 16:20:\n    # For each i from N-1 down to 0\n    for i in range(N-1, -1, -1):\n        # For each j from i+1 to N-1, process in blocks\n        for j_start in range(i+1, N, BLOCK_SIZE):\n            # Calculate block end\n            j_end = min(j_start + BLOCK_SIZE, N)\n\n            # Process each j in the block\n            for j_idx in range(j_start, j_end):\n                j = j_idx\n                if j <= i:\n                    continue\n                    ^\nunsupported AST node type: Continue\n  Test 2: ERROR - at 16:20:\n    # For each i from N-1 down to 0\n    for i in range(N-1, -1, -1):\n        # For each j from i+1 to N-1, process in blocks\n        for j_start in range(i+1, N, BLOCK_SIZE):\n            # Calculate block end\n            j_end = min(j_start + BLOCK_SIZE, N)\n\n            # Process each j in the block\n            for j_idx in range(j_start, j_end):\n                j = j_idx\n                if j <= i:\n                    continue\n                    ^\nunsupported AST node type: Continue\n  Test 3: ERROR - at 16:20:\n    # For each i from N-1 down to 0\n    for i in range(N-1, -1, -1):\n        # For each j from i+1 to N-1, process in blocks\n        for j_start in range(i+1, N, BLOCK_SIZE):\n            # Calculate block end\n            j_end = min(j_start + BLOCK_SIZE, N)\n\n            # Process each j in the block\n            for j_idx in range(j_start, j_end):\n                j = j_idx\n                if j <= i:\n                    continue\n                    ^\nunsupported AST node type: Continue\nSome tests FAILED!\n"
    }
  },
  "seidel_2d": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 8.618799e-02",
      "max_error": "8.618799e-02"
    }
  },
  "symm": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "syr2k": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 2,
    "final_error": {
      "type": "unknown",
      "message": "  Test 1: ERROR - at 9:28:\ndef syr2k_kernel(A, B, C, alpha, beta, M, N, BLOCK_SIZE: tl.constexpr):\n    i = tl.program_id(0)\n\n    if i >= N:\n        return\n\n    # First loop: C[i][j] *= beta for j <= i\n    j_offsets = tl.arange(0, BLOCK_SIZE)\n    for j_block in range(0, triton.cdiv(i + 1, BLOCK_SIZE)):\n                            ^\nValueError('Did you forget to add @triton.jit ? (`_builder` argument must be provided outside of JIT functions.)')\n  Test 2: ERROR - at 9:28:\ndef syr2k_kernel(A, B, C, alpha, beta, M, N, BLOCK_SIZE: tl.constexpr):\n    i = tl.program_id(0)\n\n    if i >= N:\n        return\n\n    # First loop: C[i][j] *= beta for j <= i\n    j_offsets = tl.arange(0, BLOCK_SIZE)\n    for j_block in range(0, triton.cdiv(i + 1, BLOCK_SIZE)):\n                            ^\nValueError('Did you forget to add @triton.jit ? (`_builder` argument must be provided outside of JIT functions.)')\n  Test 3: ERROR - at 9:28:\ndef syr2k_kernel(A, B, C, alpha, beta, M, N, BLOCK_SIZE: tl.constexpr):\n    i = tl.program_id(0)\n\n    if i >= N:\n        return\n\n    # First loop: C[i][j] *= beta for j <= i\n    j_offsets = tl.arange(0, BLOCK_SIZE)\n    for j_block in range(0, triton.cdiv(i + 1, BLOCK_SIZE)):\n                            ^\nValueError('Did you forget to add @triton.jit ? (`_builder` argument must be provided outside of JIT functions.)')\nSome tests FAILED!\n"
    }
  },
  "syrk": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  },
  "trisolv": {
    "triton_generated": true,
    "test_passed": false,
    "attempts": 5,
    "final_error": {
      "type": "numerical",
      "message": "max_error = 3.739408e+31",
      "max_error": "3.739408e+31"
    }
  },
  "trmm": {
    "triton_generated": true,
    "test_passed": true,
    "attempts": 1,
    "final_error": null
  }
}