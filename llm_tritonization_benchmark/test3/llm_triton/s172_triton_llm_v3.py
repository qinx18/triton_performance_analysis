import torch
import triton
import triton.language as tl

@triton.jit
def s172_kernel(a_ptr, b_ptr, n1, n3, LEN_1D, BLOCK_SIZE: tl.constexpr):
    # Calculate the starting index for this block
    block_start = tl.program_id(0) * BLOCK_SIZE
    
    # Generate offsets for this block
    offsets = block_start + tl.arange(0, BLOCK_SIZE)
    
    # Convert linear indices to stride pattern indices
    # We need indices that follow the pattern: n1-1, n1-1+n3, n1-1+2*n3, ...
    # So index = (n1-1) + stride_idx * n3, where stride_idx = 0, 1, 2, ...
    stride_indices = (offsets - (n1 - 1)) // n3
    actual_indices = (n1 - 1) + stride_indices * n3
    
    # Check if these are valid indices that would be generated by the original loop
    valid_stride = (offsets - (n1 - 1)) % n3 == 0
    valid_range = (actual_indices >= n1 - 1) & (actual_indices < LEN_1D)
    valid_mask = valid_stride & valid_range & (offsets < LEN_1D)
    
    # Use actual_indices for memory access
    memory_mask = (actual_indices >= 0) & (actual_indices < LEN_1D) & valid_mask
    
    # Load values
    a_vals = tl.load(a_ptr + actual_indices, mask=memory_mask, other=0.0)
    b_vals = tl.load(b_ptr + actual_indices, mask=memory_mask, other=0.0)
    
    # Compute
    result = a_vals + b_vals
    
    # Store result
    tl.store(a_ptr + actual_indices, result, mask=memory_mask)

def s172_triton(a, b, n1, n3):
    LEN_1D = a.shape[0]
    
    # Calculate total number of iterations in the strided loop
    if n3 <= 0:
        return
    
    num_iterations = (LEN_1D - (n1 - 1) + n3 - 1) // n3
    if num_iterations <= 0:
        return
    
    BLOCK_SIZE = 256
    grid_size = (num_iterations + BLOCK_SIZE - 1) // BLOCK_SIZE
    
    s172_kernel[(grid_size,)](
        a, b, n1, n3, LEN_1D, BLOCK_SIZE
    )